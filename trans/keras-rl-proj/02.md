<title>Unknown</title>  <link href="../stylesheet.css" rel="stylesheet" type="text/css"> <link href="../page_styles1.css" rel="stylesheet" type="text/css">

# 模拟随机漫步

随机过程包括根据概率定律随时间(但更普遍的是在空间)演化的系统。这种系统或模型描述了现实世界中具有随机可能性的复杂现象。这些现象比我们想象的更频繁。当我们感兴趣的量不能绝对确定地预测时，我们会遇到这些现象。然而，当这种现象表现出可能结果的可变性，可以用某种方式解释或描述时，我们就可以引入这种现象的概率模型。

例如，假设我们正在检查随机行走运动中涉及的运动。我们研究一个物体的运动，这个物体被限制在允许的两个方向上沿直线运动。在每次移动中，它随机地向右或向左移动，每一步的长度相等，并且独立于其他步骤。马尔可夫链是一个随机过程，系统的演化只取决于它的当前状态，而不取决于它的过去状态。马尔可夫链的特征在于一组状态和状态间转移的概率。想象一个点，它可以沿着一条线以离散的时间间隔随机向前或向后移动，在每个时间间隔内移动一定的距离。这是一个随机漫步的例子。在这一章中，我们将通过 Python 代码实现使用马尔可夫链来模拟随机行走。

在本章中，我们将讨论以下主题:

*   随机游动
*   随机行走模拟
*   基本概率概念
*   马尔可夫链
*   使用马尔可夫链进行预测
*   马尔可夫链文本生成器

在本章的最后，读者将知道马尔可夫过程的基本概念，随机漫步的基本概念，随机漫步算法如何工作，知道如何使用马尔可夫链预测天气，以及如何使用马尔可夫链模拟随机漫步。

<title>Unknown</title>  <link href="../stylesheet.css" rel="stylesheet" type="text/css"> <link href="../page_styles1.css" rel="stylesheet" type="text/css">

# 随机漫步

随机漫步是一种数学模型，用于描述由一系列随机步骤给出的路径，根据我们要描述的系统，这些随机步骤可能具有一定数量的自由度或方向。随机漫步这个术语是由卡尔·皮尔逊在 1905 年引入的。在随机行走中，每一步都有随机的方向，也可能有随机的维度。它代表了一种理论模型，通过遵循精确统计分布的已知量的演变来描述任何随机过程。从物理上来说，我们将要绘制的路径不一定描述真实的运动，而是更一般地表明特征随时间的演变。这意味着随机游走在物理、化学和生物学中有应用，但在其他领域也有应用，如计算机科学、经济学和社会学。

<title>Unknown</title>  <link href="../stylesheet.css" rel="stylesheet" type="text/css"> <link href="../page_styles1.css" rel="stylesheet" type="text/css">

# 一维随机行走

在一维随机行走中，我们研究了一个点状粒子的运动，该粒子被限制在仅两个方向中的一个方向(左和右)上沿直线运动。对于每次(随机)移动，它可以以固定的概率 ***p*** 向右移动一步，或者以 ***q*** 的概率向左移动一步。每个步骤的长度相等，并且独立于其他步骤，如下图所示:

![](Images/eab721bc-7c33-4cea-a0c5-e267346c047d.png)

点在第 *n* 步之后的位置——由其横坐标*X(n)——*标识——显然包含随机项。我们想计算在 *n* 次运动后，粒子回到起点的概率(需要注意的是，没有任何东西能向我们保证这个点真的会回到那个位置)。为此，我们将使用 *X(n)* 变量，它给出了粒子向左移动 *n* 步后直线的横坐标。显然，这是一个二项分布的离散随机变量。

该变量采用如下方案:在每一个瞬间， *n* 根据随机变量 *Z(n)* 的结果向右或向左移动一步，其取值为+1，概率为 *p > 0* ，取值为-1，概率为 *q* ，其中 *p + q = 1* ，如上图所示。假设随机 *Zn* 变量与 *n = 1，2，...*都是独立的，都有相同的分布。那么粒子在 *n* 时刻的位置由下式给出:

![](Images/45fa3faa-0ca1-44d3-8a69-2ec957e47212.png)

*X[n]变量代表马尔可夫链，因为为了确定粒子在下一时刻处于某一位置的概率，我们只需要知道它在当前时刻的位置，即使我们知道它在当前时刻之前的所有时刻的位置。*

<title>Unknown</title>  <link href="../stylesheet.css" rel="stylesheet" type="text/css"> <link href="../page_styles1.css" rel="stylesheet" type="text/css">

# 模拟 1D 随机漫步

我们以前说过，随机游走包含一个随机项。要模拟随机行走，生成一个随机数列表是不够的，因为序列中的下一个值是前一个值的修改。这种依赖性提供了从一个段落到下一个段落的某种连贯性，这在独立随机数的生成中不会发生，而是显示了从一个数字到下一个数字的巨大跳跃。

可以通过下面的伪代码模拟一个简单的随意行走的模型:

1.  从位置 0 开始
2.  随机选择一个值为-1 或 1 的数字
3.  将其添加到前一时间步的观测值中
4.  从步骤 *2* 开始重复这些步骤

要在 Python 中实现该算法，只需参考前面的等式:

![](Images/3ffec4b9-3674-477d-af5c-5e4c8d3becf5.png)

在这个公式中，*X[n]是行走中的下一个值， *X [n-1]* 是上一个时间步的观测， *Z [n]* 是当时的随机波动。在 Python 中，它是通过循环这个过程并为随机行走建立 1，000 个时间步长的列表来获得的。以下显示了生成随机漫步的 Python 代码:*

```
from random import seed
from random import random
from matplotlib import pyplot
seed(4)
RandomWalk = list()
RandomWalk.append(-1 if random() < 0.5 else 1)
for i in range(1, 1000):
  Zn = -1 if random() < 0.5 else 1
  Xn = RandomWalk[i-1] + Zn
  RandomWalk.append(Xn)
pyplot.plot(RandomWalk)
pyplot.show()
```

我们将逐行分析这段代码。第一行加载库:

```
from random import seed
from random import random
```

Python 中的`random`模块包含许多用于各种发行版的随机数生成器。对于整数，我们使用一个范围内的统一选择。对于序列，我们使用一个随机元素的统一选择，一个函数生成一个随机排列的列表，一个函数用于随机抽样而不替换。

该模块加载了两个函数:`seed`和`random`。`seed`函数设置随机数发生器的种子，这对于创建模拟或可复制的随机对象很有用。每当你想得到一个可重复的随机结果时，你必须使用这个函数。在这种情况下，随机数是相同的，无论我们在序列中走多远，它们都将继续相同。每个种子值将对应于为给定随机数生成器生成的一系列值。也就是说，如果您两次提供相同的种子，您会得到两次相同的数字序列。

`random`函数返回[0.0，1.0]范围内的下一个随机浮点数。加载了另一个重要的库。这是`matplotlib`库，如下面的代码所示:

```
from matplotlib import pyplot
```

Matplotlib 是一个 Python 2D 绘图库，它以各种硬拷贝格式和跨平台的交互环境生成出版物质量的图形。Matplotlib 试图让简单的事情变得简单，让困难的事情变得可能。只需几行代码就可以生成图表、直方图、功率谱、条形图、误差图、散点图等等。它由一组命令风格的函数组成，使 Matplotlib 像 MATLAB 一样工作。每个`pyplot`函数对一个图形进行改变，比如创建一个图形，在一个图形中创建一个绘图区，在一个绘图区中绘制一些线，用标签装饰绘图等等。

在正确导入库之后，我们传递一个命令来分析各个操作。让我们从使用以下代码设置`seed`开始:

```
seed(4)
```

回想一下，如果您两次提供相同的种子，那么您会得到两次相同的数字序列。让我们继续创建主变量，如下面的代码所示:

```
RandomWalk = list()
```

`RandomWalk`变量将是包含代表随机游走的值序列的变量。该变量将属于`list`类型。列表是值的有序集合，可以包含各种类型的值。列表是一个可变的容器。这意味着我们可以添加值、删除值或修改现有值。Python 列表表示有限序列的数学概念。对于我们的需求(可变值的序列)，列表代表最合适的容器。`list()`方法接受序列类型并将它们转换成列表。首先，需要初始化列表的第一个值，如下面的代码所示:

```
RandomWalk.append(-1 if random() < 0.5 else 1)
```

这个值将在下一次计算中为我们服务。我们可以继续迭代循环，如下面的代码所示:

```
for i in range(1, 1000):
```

在每一步，我们得到以下随机项:

```
Zn = -1 if random() < 0.5 else 1
```

将返回两个值:`-1`和`1`。如果`random`函数(您可能还记得，它返回[0.0，1.0]区间内的值)返回一个低于`0.5`的值，我们就得到`-1`；否则，我们得到`1`。此时，我们可以使用以下代码评估当前步骤中的行走值:

```
Xn = RandomWalk[i-1] + Zn
```

那么当前步速下的行走值将由前一步的行走值和随机项之和给出。计算后，该值必须添加到列表中，如下所示:

```
RandomWalk.append(Xn)
```

将对第 *n* 个编程步骤重复该程序。最后，我们将把整个序列存储在列表中。我们只需要将它可视化，如下面的代码所示:

```
pyplot.plot(RandomWalk)
pyplot.show()
```

`pyplot.plot`短语使用数组 *0 在 *y* 轴上绘制`RandomWalk`....N-1* 作为 *x* 轴。`plot() `短语是一个通用命令，可以接受任意数量的参数。最后，`pyplot.show`显示创建的图表。

下图显示了用前面的代码绘制的随机游走:

![](Images/da1ac265-e44b-4df9-b7be-ff6f3e133c1c.png)

在图中，我们看到一个描述特定函数趋势的随机过程。在其中，下一步独立于上一步的位置，仅取决于当前步骤。随机漫步是一个自然模型，可以用来模拟**有效市场** **假设**(**EMH**)——即价格根据新信息的到来而变化的理论，根据定义，新信息独立于我们已经知道的东西。

<title>Unknown</title>  <link href="../stylesheet.css" rel="stylesheet" type="text/css"> <link href="../page_styles1.css" rel="stylesheet" type="text/css">

# 马尔可夫链

马尔可夫链是一种随机现象的数学模型，它随着时间的推移而演变，过去只通过现在影响未来。时间可以是离散的(一个整体变量)，连续的(一个实变量)，或者，更一般地，一个完全有序的整体。在这个讨论中，只考虑离散链。马尔可夫链是安德烈·安德烈耶维奇·马尔可夫(1856-1922)于 1906 年引入的，其名称也由此而来。

上一节看到的一维随机游走的例子是马尔可夫链；链中的下一个值是比当前值大或小的单位，具有相同的出现概率，与当前值的到达方式无关。

<title>Unknown</title>  <link href="../stylesheet.css" rel="stylesheet" type="text/css"> <link href="../page_styles1.css" rel="stylesheet" type="text/css">

# 随机过程

为了提供马尔可夫链的正式定义，首先需要说明一组具有时间顺序的随机变量的含义。这样一组随机变量最好用随机过程来表示。

我们使用以下随机变量序列来定义离散时间和离散状态中的随机过程:

![](Images/fc147201-5f05-48ca-9043-58cfab0c3784.png)

这里，每个*X[n]都是一个离散的随机变量，其值在一个 *S = s [1] ，s [2] ，…，s [n]* 集合中，称为状态空间。不失一般性，假设 *S* 是相对整数 *Z* 的子集。我们将使用*X[n]T21 的索引 *n* 来表示状态演化的时间；我们称之为状态，值为*X[n]的可能状态。该过程从这些状态之一开始，并从一个状态连续移动到另一个状态。每一步都叫做一步。***

久而久之，这个过程可以从一个状态跳到另一个状态。如果系统在时间步 *n* 期间处于状态 *i* ，并且在时间步 *n* +1 期间处于状态 *j ≠ i* ，那么我们说已经发生了转变。

<title>Unknown</title>  <link href="../stylesheet.css" rel="stylesheet" type="text/css"> <link href="../page_styles1.css" rel="stylesheet" type="text/css">

# 概率计算

我们感兴趣的是计算与随机过程( *X [n]* )相关的概率。让我们花几分钟来谈谈概率的基本概念。如果您已经熟悉这些概念，您可能想跳过这一节；否则，加深理解概率如何计算所需的基础知识将对你有利。

给定事件( *E* )发生的先验概率是事件本身有利情况的数量( *s* )与可能情况的总数( *n* )之间的比率，假设所有考虑的情况都是同等可能的。这可以用下面的公式来概括:

![](Images/0333abab-c624-41f6-90ad-de34e0e91c31.png)

让我们看一个简单的例子。

掷出的骰子显示数字 3 的概率是多少？可能结果的数量是 6— *{1，2，3，4，5，6}—* ，有利的情况是 *1{3}* 。所以 *P(3) =1/6 =0.166 =16.6 %* 。

事件的概率( *P(E)* )始终是一个介于 0 和 1 之间的数字，如下式所示:

![](Images/e721c470-bee1-4c25-9857-4938f3f1d3c5.png)

极值定义如下:

*   概率为 *0* 的事件称为不可能事件。假设我们有六个红色的球在一个袋子里。选黑球的概率有多大？可能案例数为 6，有利案例数为 0，因为袋子里没有黑球。我们可以把这个总结为 *P(E) = 0/6 = 0* 。

*   概率为 1 的事件称为确定事件。假设我们有六个红色的球在一个袋子里。挑到红球的概率有多大？可能情况的数量是 6，有利情况的数量是 6，因为袋子里只有红球。我们可以把这个总结为 *P(E) = 6/6 =1* 。

到目前为止，我们已经讨论了事件的可能性，但是当可能的事件不止一个时会发生什么呢？如果事件 *A* 发生的概率不依赖于事件 *B* 是否发生，则两个随机事件 *A* 和 *B* 是独立的，反之亦然。例如，假设我们有两副 52 张的法国扑克牌。从每副牌中抽取一张牌时，以下两个事件是独立的:

*   *E [1]*
*   *E [2]*

这两个事件是独立的——每一个都以相同的概率独立于另一个事件发生。

相反，如果事件 *A* 的概率取决于事件 *B* 是否发生，则随机事件 *A* 依赖于另一个事件 *B* 。假设我们有一副 52 张牌。通过连续抽取两张牌，而不将第一张牌放回牌组，以下两个事件是相关的:

*   *E [1]*
*   *E [2]*

准确的说，*E[2]的概率取决于*E[1]是否发生。由此，我们可以推断如下:**

*   *E[1]T3 的概率是 4/52*
*   如果第一张牌是 a，那么出现*E[2]T3 的概率是 3/51*
*   如果第一张牌不是 a，那么 *E* *[2]* 的概率是 4/51

现在让我们来处理**联合概率**的情况，既有独立的，也有相依的。如果两个事件 *A* 和 *B* 是独立的(意味着一个事件的发生不影响另一个事件的概率)，那么事件的联合概率等于 *A* 和 *B* 的概率的乘积。这可以总结如下:

![](Images/47964077-10b8-47f7-b0ea-9d60d99fd471.png)

我们举个例子。我们有两副 52 张的牌。通过从每副牌中抽取一张牌，让我们考虑两个独立的事件:

*   *A* :从第一副牌中抽出的牌是 A
*   *B* :从第二副牌中抽出的牌是一张梅花牌

两者发生的概率有多大？

*   *P(A)* *= 4/52*
*   *P(B) = 13/52*
*   *P(A∩B)**= 4/52 * 13/52 = 52/(52 * 52)= 1/52*

如果两个事件是相关的(也就是说，一个事件的发生影响另一个事件的概率)，那么可以应用相同的规则，假设 *P(B|A)* 是事件 *B* 的概率，假定事件 *A* 已经发生。这个条件引入了**条件概率**，我们将深入探讨。这可以总结如下:

![](Images/4a9fb3c8-0dcd-4362-a627-17194c26e5ad.png)

假设一个包里有两个白球和三个红球。在两次连续抽取中从袋中取出两个球，而不重新引入从袋中取出的第一个球。

根据以下事实，计算抽取的两个球都是白色的概率:

*   第一个球是白球的概率是 *2/5*
*   假设第一个球是白色的，第二个球是白色的概率是 *1/4*

有两个白球的概率如下:

*   *P(二白)= 2/5 * 1/4 = 2/20 = 1/10*

正如所承诺的，现在是时候引入条件概率的概念了。事件 *B* 发生的概率，在事件 *A* 发生的条件下计算，称为**条件概率**，用 *P(B | A)* 表示。它使用以下公式计算:

![](Images/7cc759ad-e1c5-475a-8fc5-89a07f8888ed.png)

既然我们能够理解不同种类的概率，让我们将它们应用于随机过程。让我们从最简单的一种概率开始，写成 *P(X [n] = i)* 。

这表示在步骤 *n* 观察到系统处于状态 *i* 的概率。除了这些简单的概率，我们还可以对更复杂的概率的计算感兴趣，例如那些同时涉及多个步骤的概率。

例如，计算在步骤 *n + 1* 处于状态 *j* 的概率可能是有趣的，已知它在步骤 *n* 处于状态 *i* (您可能已经注意到，这是先前定义的条件概率)。这可以总结如下:

![](Images/8c6afffa-506e-47d7-a3dd-03732bb6a7e2.png)

这在步骤 *n* 计算从 *i* 到 *j* 的转移概率。使用条件概率定义，它将自身改写为以下形式:

![](Images/c00504fd-2199-4e0e-a429-768dd1636da1.png)

因此，对于该计算，我们知道先验概率和联合概率就足够了。我们知道，为了计算更复杂的表达式，有必要知道由以下公式给出的通用联合概率:

![](Images/3afa9ec4-6437-42e0-893b-7ca96b77bf75.png)

其中 *i [0] ，..., .i [n] ∈ Z* 。在某种意义上，这些概率穷尽了所有可能的信息；当所有组合的(离散的)密度已知时，即所有多个离散变量 *(X [l] 的密度，...，X [n] )* 到所有 *i [0] 的变化，..., .i [n] ∈ Z* 。这些联合概率的计算通常是难以处理的。

<title>Unknown</title>  <link href="../stylesheet.css" rel="stylesheet" type="text/css"> <link href="../page_styles1.css" rel="stylesheet" type="text/css">

# 马尔可夫链定义

正如我们所说的，马尔可夫链是一个随机现象的数学模型，它随着时间的推移以这样一种方式演变，即过去只通过现在影响未来。换句话说，随机模型描述了一系列可能的事件，其中每个事件的概率只取决于前一个事件达到的状态。因此，马氏链具有无记忆性。

让我们考虑一个由随机变量序列描述的随机过程， *X = X [0] ，...，X[n]，可以取 a *j [0] ，j [1] ，…，j [n]* 集合中的值。如果过程的演化仅通过现在依赖于过去——也就是说，我们在第 *n* 步后发现自己所处的状态——我们会说它具有马尔可夫性质。这可以定义如下:*

![](Images/ef0ba5d3-2aef-4ee2-9b4d-c2d0428f0338.png)

如果参数是明确定义的条件概率，那么这个关系必须适用于所有的参数。具有马尔可夫性质的离散时间随机过程 *X* 称为马尔可夫链。如果以下转移概率不依赖于 *n* ，而仅依赖于 *i* 和 *j* ，则称马尔可夫链是齐次的:

![](Images/ddec7a93-ceb0-4694-8292-8d28f0a173e3.png)

发生这种情况时，将对公式进行以下更改:

![](Images/b0cf4acd-220a-44e4-bdaa-52c9cdea178d.png)

鉴于此，我们可以通过知道数字*p[ij]加上以下初始分布来计算所有的联合概率:*

![](Images/f56706c4-737e-41a4-8080-edd3e7367c9f.png)

这个概率叫做过程在时间零点的分布。将*p[ij]概率称为转移概率，具体来说，*p[ij]T7 是在一个时间步长内从 *i* 转移到 *j* 的概率。**

<title>Unknown</title>  <link href="../stylesheet.css" rel="stylesheet" type="text/css"> <link href="../page_styles1.css" rel="stylesheet" type="text/css">

# 跃迁矩阵

使用矩阵表示，时间齐次马尔可夫链(其转移概率与时间无关)的研究变得特别简单和有效。特别是前一个命题所表达的公式，可读性就变得强多了。因此，马尔可夫链的结构完全由下面的转移矩阵表示:

![](Images/d63ea677-40cb-4da9-ac5b-718247081857.png)

转移概率矩阵的性质直接来源于组成它们的元素的性质。事实上，通过观察矩阵的元素是概率，它们必须具有 0 和 1 之间的值。所以，这是一个正矩阵，其中每行元素的和是酉的。事实上， *i* 行的元素是链在 *t* 时刻处于*S[I]状态，在*S[1]或*S[2]跃迁的概率，...或者在下一步的*S[n]中，这样的转换是互斥的，并且穷尽了所有的可能性。这样的矩阵(具有单位和行的正矩阵)称为随机矩阵，我们将每个正行向量称为随机矩阵，如下所示:****

![](Images/564cb8fd-763d-4798-a64f-abfb9c60b00e.png)

在此向量中，元素之和取单位值，如下式所示:

![](Images/67926cdc-4321-44d3-b8f8-c787563cb3f5.png)

现在我们会看到，在一维随机行走的情况下，这种特殊的形式假设了这个矩阵。如前所述，在一维随机行走中，我们研究了一个点状粒子的运动，该粒子被限制为只能在两个方向(左和右)上沿直线运动。

它可以以固定概率 **p** 向右(随机)移动一步，或者以概率 **q** 向左移动 *p + q = 1* 。每个步骤的长度相等，并且独立于其他步骤，如下图所示:

![](Images/2ccf6b34-ff5e-484c-83ef-9dd197dd993f.png)

假设*Z[n]T3*n = 1，2 的随机变量...*都是独立的，都有相同的分布。那么粒子 *n* 的直接位置由下面的公式给出:*

![](Images/b7fbe20f-1fb4-4baa-8f34-cc4e3417c71c.png)

这里， *X [0] = 0* ，状态空间为 *S = (0，1，2，…)* 。 *X [n]* 过程是一个马尔可夫链，因为，为了确定粒子在下一个时刻处于某个位置的概率，我们只需要知道它在当前时刻的位置，即使我们知道它在当前时刻之前的所有时刻的位置。这可以总结如下:

![](Images/cbc39532-5617-446e-afd8-da0de7deb632.png)

在这里，*Z[n]变量是独立的。转移矩阵是一个有限行和有限列的矩阵，主对角线上有 *0* ，主对角线上有 *p* ，主对角线下有 *q* ，其他地方有 *0* ，如下图所示:*

![](Images/51b598d9-24f2-4468-9a39-5d54a779ad17.png)

显然，这种概括大大简化了问题。

<title>Unknown</title>  <link href="../stylesheet.css" rel="stylesheet" type="text/css"> <link href="../page_styles1.css" rel="stylesheet" type="text/css">

# 推移图

通过转移矩阵描述马尔可夫链的一个非常直观的替代方法是将有向图(转移图)与马尔可夫链相关联，下面两个语句适用于该马尔可夫链:

*   顶点由状态的 *S [1] ，S [2] ，…，S [n]* 来标记(或者，简单地说，从状态的索引 1，2，…, *n*
*   当且仅当从 *S [i] 到*S[j]的转移概率为正(该概率又被用作边本身的标签)时，存在将*S[I]顶点连接到*S[j]顶点的有向边****

很明显，转移矩阵和转移图提供了关于相同马尔可夫链的相同信息。为了理解这种二元性，我们可以看一个简单的例子。假设我们有一个马尔可夫链，它有三种可能的状态:1、2 和 3，以及下面的转移矩阵:

![](Images/0907726c-1d78-4b85-b91e-9aa0066b5911.png)

下图显示了上述马尔可夫链的转换。在这个图中，有三种可能的状态——**1**、 **2** 和**3**——从每个状态到其他状态的有向边显示了转移概率*p[ij]。当没有从状态 *i* 到状态 *j* 的箭头时，表示 *p [ij] =0* :*

![](Images/378dd9d4-33d1-419a-8dad-5086f64db0cf.png)

在上图中，我们可以看到，从一个状态出来的箭头总是在 **1** 处正好相加，就像转移矩阵中每一行的值必须正好相加到 **1** 处，这代表了概率分布。从转移矩阵和转移图之间的比较，可以理解两种资源之间的二元性。和往常一样，图表更能说明问题。

<title>Unknown</title>  <link href="../stylesheet.css" rel="stylesheet" type="text/css"> <link href="../page_styles1.css" rel="stylesheet" type="text/css">

# 用马尔可夫链进行天气预报

我们想建立一个统计模型来预测天气。为了简化模型，我们将假设只有两种状态:晴天和雨天。让我们进一步假设，我们已经进行了一些计算，并发现明天的时间在某种程度上是基于今天的时间，根据以下转换矩阵:

![](Images/e5694d8b-30db-4959-b142-269b58f36442.png)

回想一下，这个矩阵包含表示为 *P (A | B)—* 类型的条件概率，即给定 *B* 时 *A* 的概率。因此，这个矩阵包含以下条件概率:

![](Images/616530ca-fc89-4307-85fa-3454285ecc60.png)

在前面的矩阵中，**【苏】** =晴天， **Ra** =雨天。每一行必须包含一个完整的分布；因此，所有数字都必须是非负的，并且总和为 1。天气有抵制变化的趋势——例如， *P(晴|晴)*比 *P(晴|雨)*更有可能。明天的价值与昨天(或更早的时间)的价值没有直接关系，所以这个过程是马尔可夫的。

前面的矩阵对应于下面的转换图:

![](Images/611ca4ad-1bc6-476d-96bb-c8a6443f9fd9.png)

此时，我想到了以下问题:

*   如果今天是晴天，如何计算未来几天是雨天的概率？
*   一定天数后，晴天和雨天的比例会是多少？

这两个问题，以及许多其他可以想到的问题，都可以通过使马尔可夫链对我们可用的工具来回答。以下是从特定初始条件开始提供晴天和雨天交替的 Python 代码:

```
import numpy as np
import time
from matplotlib import pyplot

np.random.seed(1)
states = ["Sunny","Rainy"]

TransStates = [["SuSu","SuRa"],["RaRa","RaSu"]]
TransnMatrix = [[0.75,0.25],[0.30,0.70]]

if sum(TransnMatrix[0])+sum(TransnMatrix[1]) != 2:
    print("Warning! Probabilities MUST ADD TO 1\. Wrong transition matrix!!")
    raise ValueError("Probabilities MUST ADD TO 1")

WT = list()
NumberDays = 200
WeatherToday = states[0]
print("Weather initial condition =",WeatherToday)

i = 0
while i < NumberDays:
    if WeatherToday == "Sunny":
        TransWeather = np.random.choice(TransStates[0],
                                replace=True,p=TransnMatrix[0])
        if TransWeather == "SuSu":
            pass
        else:
            WeatherToday = "Rainy"
    elif WeatherToday == "Rainy":
            TransWeather = np.random.choice(TransStates[1],
                                replace=True,p=TransnMatrix[1])
            if TransWeather == "RaRa":
                pass
            else:
                WeatherToday = "Sunny"
    print(WeatherToday)
    WT.append(WeatherToday)
    i += 1
    time.sleep(0.2)

pyplot.plot(WT)
pyplot.show()

pyplot.hist(WT)
pyplot.show()
```

我们将逐行分析这段代码。第一行加载库:

```
import numpy as np
import time
from matplotlib import pyplot
```

第一行导入了`numpy`库:`numpy`是 Python 编程语言的库，增加了对大型多维数组和矩阵的支持，以及对这些数组进行操作的大量高级数学函数。将使用两个功能:`random.seed()`和`random.choise()`。第二行导入了`time`模块，该模块提供了各种与时间相关的函数。最后，从`matplotlib`库中导入`pyplot`模块。

让我们继续分析代码:

```
np.random.seed(1)
```

`random.seed()`函数设置随机数发生器的种子，这对于创建模拟或可复制的随机对象很有用。每当你想得到一个可重复的随机结果时，你必须使用这个函数。在这种情况下，随机数是相同的，无论我们在序列中走多远，它们都将继续相同。每个种子值将对应于为给定随机数生成器生成的一系列值。在下面一行中，我们定义了天气状况的状态:

```
states = ["Sunny","Rainy"]
```

我们说过，只提供两种状态:`Sunny`和`Rainy`。此时，我们必须定义天气条件的可能转变:

```
TransStates = [["SuSu","SuRa"],["RaRa","RaSu"]]
```

只有两种状态只允许四种类型的转换:晴到晴、晴到雨、雨到雨、雨到晴。让我们继续根据本节开始时确定的内容来定义过渡矩阵:

```
TransnMatrix = [[0.75,0.25],[0.30,0.70]]
```

请记住，这个矩阵包含表示为 *P (A | B)—* 的类型的条件概率，即给定 *B* 时 *A* 的概率。正如已经提到的，这个矩阵的行加起来是 1。然后，我们插入以下检查，以验证我们在定义转换矩阵时没有出错:

```
if sum(TransnMatrix[0])+sum(TransnMatrix[1]) != 2:
    print("Warning! Probabilities MUST ADD TO 1\. Wrong transition matrix!!")
    raise ValueError("Probabilities MUST ADD TO 1")
```

让我们继续使用下面的代码创建主变量:

```
WT = list()
```

`WT`短语将是包含代表天气预报的值序列的变量。该变量将属于`list`类型。现在，让我们使用以下代码来确定我们想要预测天气状况的天数:

```
NumberDays = 200
```

如果我们想固定另一个时间间隔，改变这个值就足够了。现在，让我们使用以下代码来修复初始条件:

```
WeatherToday = states[0]
```

这样，我们选择了`states`变量的第一个元素。请记住，在 Python 中，列表的第一个元素的索引等于`0`。现在，我们可以继续看天气预报了。但是首先，我们使用下面的代码设置初始条件:

```
print("Weather initial condition =",WeatherToday)
```

我们现在可以预测由`NumberDays`变量设定的每一天的天气情况。为此，我们将使用一个`while`循环。一个`while`循环不同于一个`for`循环，但是基本上，它执行相同的功能。它由控制条件和循环体组成。在循环开始时，以及每次执行主体中包含的所有指令时，都要验证控制条件的有效性。当由布尔表达式组成的条件返回`false`时，循环结束。首先，我们初始化一个计数器来执行检查，如下所示:

```
i = 0
```

我们设定的退出条件是`i <NumberDays`。这意味着当这个布尔表达式为`false`(而当`i = NumberDays`时就会出现这种情况)，那么循环就不会被执行，它会转到`while`块后的第一条语句，如下面的代码所示:

```
while i < NumberDays:
    if WeatherToday == "Sunny":
        TransWeather = np.random.choice(TransStates[0],replace=True,p=TransnMatrix[0])
        if TransWeather == "SuSu":
            pass
        else:
            WeatherToday = "Rainy"
    elif WeatherToday == "Rainy":
        TransWeather = np.random.choice(TransStates[1],replace=True,p=TransnMatrix[1])
        if TransWeather == "RaRa":
            pass
        else:
            WeatherToday = "Sunny"
    print(WeatherToday)
    WT.append(WeatherToday)
    i += 1
    time.sleep(0.2)
```

这是整个节目的主要部分，所以你需要密切注意。在`while`循环中，连续每一天的时间预测通过一个进一步的条件结构进行:语句`if`。从一个天气条件出发(记得我们一开始就确立了天气条件是晴天)，必须提供第二天的天气条件。因此，我们可以从两个条件出发:`Sunny`或`Rainy`。

实际上，第一个`if`语句提供了两个控制条件，如下面的截图所示:

![](Images/e9976260-4e57-4f82-87cd-f7f42a2205e6.png)

从天气状况(`Sunny`或`Rainy`)开始，`random.choice()`功能用于预测。如前所述，这个函数从一个给定的一维数组中生成一个随机样本。该函数的语法如下:

```
numpy.random.choice (a, size = None, replace = True, p = None)
```

让我们更详细地看看这段代码:

*   `a`:1-D array-like or`int`—如果这是一个*n array*，从它的元素中产生一个随机样本。如果这是一个`int`，就像`a`是`np.arange (a)`一样产生随机样本。

*   `size` : `int`或`int`实例的元组。这有一个可选的输出形状。如果给定的形状是，例如，( *m* ， *n* ， *k* )，那么*m*∫*n*∫*k*个样本被绘制。默认值是`None`，在这种情况下返回单个值。

*   `replace` : `Boolean`。这是可选的，无论样品是否有替代品。

*   `p`:一维类数组。这是可选的。这表示与`a`中每个条目相关的概率。如果没有给定样本，那么假设`a`中的所有条目都是均匀分布的。

生成的随机样本被返回——在我们的例子中，作为下列值之一:`SuSu`、`SuRa`、`RaRa`和`RaSu`。前两个从`Sunny`状态开始，另外两个从`Rainy`状态开始。这些值存储在`TransWeather`变量中。

在每个条件(`if`和`elif`子句)中，还有一个进一步的`if`语句。我们需要这个来确定是进行转换还是保持时间不变(将其设置为前一天)。例如，在阳光充足的启动条件下，我们使用以下公式:

```
if TransWeather == "SuSu":
    pass
else:
    WeatherToday = "Rainy"
```

如果`TransWeather`变量包含值`SuSu`，那么`WeatherToday`变量的内容(包含当天的天气情况)保持不变；否则，它被替换为`Rainy`值。当然，这适用于从阳光充足的条件下开始。对于`elif`条款，可以做出类似的推理。`while`循环中的最后一段代码允许我们更新当前迭代的值，如以下代码所示:

```
print(WeatherToday)
WT.append(WeatherToday)
i += 1
time.sleep(0.2)
```

第一行在视频上显示当前的天气状况。第二行将当前状态存储在一个列表中，以记录天气状况的变化。这些值将返回用于绘制图表有用信息。第三行将循环计数器增加一个单位。最后一行调整值的打印时间，使其可读。

此时，我们已经生成了未来 200 天的预测。让我们使用以下代码绘制图表:

```
pyplot.plot(WT)
pyplot.show()
```

`pyplot.plot`短语使用数组 *0 在 *y* 轴上绘制`WT`(包含未来 200 天天气状况的列表)...N-1* 作为 *x* 轴。`plot()`短语是一个通用命令，可以接受任意数量的参数。最后，`pyplot.show`显示已经创建的图。下图显示了从晴天开始的未来 200 天的天气状况:

![](Images/1d5c251d-0238-4d03-b950-2b9e0ffc654b.png)

乍一看，阳光灿烂的日子似乎胜过了阴雨连绵的日子。可以肯定的是，我们可以画一个直方图。事实上，直方图将返回分布中计算的每个类的值的数量，如以下代码所示:

```
pyplot.hist(WT)
pyplot.show()
```

下图显示了未来 200 天的天气状况直方图:

![](Images/174ef131-4e4d-4955-9574-eab908758384.png)

正如所料，我们已经证实了**晴天**的普遍存在。这个结果似乎并不出人意料，因为它是基于转移矩阵。事实上，预测是根据这些信息得出的。如果我们再次分析我们开始的转移矩阵，我们可以看到一个**晴朗**条件的持续概率大于一个**多雨**条件的持续概率。此外，启动条件被设定为**晴天**条件。这可能是一个有用的练习，看看当我们从一个多雨的条件出发时会发生什么。为此，只需修改初始条件。

<title>Unknown</title>  <link href="../stylesheet.css" rel="stylesheet" type="text/css"> <link href="../page_styles1.css" rel="stylesheet" type="text/css">

# 用马尔可夫链生成伪随机文本

自动文本生成是全世界程序员都在努力应对的挑战之一。这种兴趣的原因是对可以帮助文本生成的自动系统的需求。想想那些在我们键入单词时自动补全单词的应用程序，或者那些在我们键入单词时在搜索中添加句子的应用程序。由此可见，使用给定语料库生成随机文本是机器学习算法中一个非常有吸引力的课题。

请记住，语料库是一个大型的结构化文本集，通常以电子方式存储和处理。语料库用于执行统计分析和假设检验，检查出现的情况，或验证特定语言范围内的语言规则。

解决这个问题的第一个方法是随机使用单词，然后将它们组合在一起，但结果将是一个难以辨认的文本。相反的情况应该是正确的:生成的文本中的单词应该按照给人以文本是由人生成的印象的顺序出现。

这个问题的一个解决方案可能是使用马尔可夫链。正如在前面的章节中已经详细解释的，马尔可夫链是一个具有马尔可夫性质的随机过程。有了这个属性，系统状态的改变只取决于系统的当前状态，而不应该比前面的步骤更依赖于系统状态。

使用马尔可夫链生成伪随机文本的过程概括为以下步骤:

1.  从语料库中抽取两个连续的单词。
2.  建立一个单词链。链中的最后两个词代表马尔可夫链的当前状态。
3.  在语料库中搜索最后两个单词的所有匹配项。这将代表当前状态。如果它们出现不止一次，那么我们随机选择一个，并把它后面的单词添加到链的末尾。
4.  此时，当前状态被更新；它由前一个链队列的第二个字和新字组成。
5.  重复从*步骤 3* 开始的所有步骤，直到我们达到生成文本的期望长度。

当阅读一个语料库并将其细分为单词时，我们不会删除逗号、标点符号等等。这样，我们会得到一个更真实的文本。

基于马尔可夫链的文本生成器需要一个初始语料库。事实上，与任何机器学习算法一样——即使是文本生成器——我们首先必须通过向它提供一组初始数据来训练我们的算法。

为此，我们将使用一本美国文学名著:马克·吐温的《汤姆·索亚历险记》。这将是我们的文集；我们将以文本格式保存它(使用 UTF-8 字符集编码)。

对于文本生成，我们将使用`markovify` Python 库。Markovify 是一个简单的，可扩展的马尔可夫链生成器。它的主要用途是建立大型文本语料库的马尔可夫模型，并从中生成随机句子。

要获得更多信息并下载源代码，我们可以参考位于[https://github.com/jsvine/markovify](https://github.com/jsvine/markovify)的 Markovify 项目资源库。

上述发电机的使用很简单。请注意以下简单的规则:

*   为了从语料库中生成文本，我们使用了`markovify.Text`类。
*   文本生成器最适用于大且标点正确的文本。如果文本不使用标点符号来描述句子，您将需要在新的一行中分隔每个句子。在这种情况下，您将需要使用`markovify.NewlineText`类。
*   默认情况下，`markovify.Text`最多尝试执行十次与原文不重叠的句子。如果成功，该方法将句子作为字符串返回；否则返回`None`。
*   如果文本是一个长句，Markovify 将不能生成新的句子，因为缺少开始和结束分隔符。
*   默认情况下，`markovify.Text`试图生成不只是返回原始文本片段的句子。默认规则是删除任何与 15 个单词或句子字数的 70%的原始文本完全重叠的生成短语。

要安装 Markovify 文本生成器，只需输入以下命令:

```
pip install markovify
```

`pip`短语是安装 Python 包的工具。

以下代码显示了如何从马克·吐温的杰作中生成伪随机文本:

```
import markovify

with open("corpus.txt") as f:
    CorpusText = f.read()

    TextModel = markovify.Text(CorpusText)

print("Five randomly-generated sentences")
print("---------------------------------")

for i in range(5):
    print(TextModel.make_sentence())

print("---------------------------------")
print("three randomly-generated sentences of no more than 100 characters")
print("---------------------------------")

for i in range(3):
    print(TextModel.make_short_sentence(100))
```

我们将逐行分析这段代码。第一行加载库:

```
import markovify
```

让我们继续使用下面的代码加载语料库:

```
with open("corpus.txt") as f:
    CorpusText = f.read()
```

首先，我们必须打开文件。为此，我们使用了返回一个`file`对象的`open()`函数，它最常用于两个参数:`open(filename, mode)`。第一个参数是包含文件名的字符串。第二个参数是另一个字符串，包含几个描述文件使用方式的字符。在我们的例子中，只传递文件名。

为了读取语料库的内容，我们调用了`f.read(size)`函数，该函数读取大量数据并将其作为字符串返回。`size`短语是一个可选的数字参数(在我们的例子中，它被省略了)。当`size`被省略或为负值时，将读取并返回文件的全部内容。

此时，我们可以使用以下代码创建模型:

```
 TextModel = markovify.Text(CorpusText)
```

这是这个包的主类，正如我们已经说过的，它创建了从语料库中生成要打开的文本的模型。这个模型已经训练好了，可以使用了。您可以创建的最有用的`markovify.Text`模型如下:

*   `sentence_split`
*   `sentence_join`
*   `word_split`
*   `word_join`
*   `test_sentence_input`
*   `test_sentence_output`

现在模型已经准备好了，我们可以开始生成句子了。在此之前，我们使用`print`函数在屏幕上打印格式化行，使输出更具可读性，如下面的代码所示:

```
print("Five randomly-generated sentences")
print("---------------------------------")
```

正如所料，我们将首先使用以下代码生成五个句子:

```
for i in range(5):
    print(TextModel.make_sentence())
```

为此，我们首先使用一个`for`循环，然后使用`TextModel.make_sentence ()`函数。这个函数从你的模型生成一个句子。默认情况下，根据我们之前创建的模型，我们会尝试十次来生成一个有效的句子。如果成功，它将句子作为字符串返回。如果不是，它返回`None`。最后，我们使用下面的代码生成三个长度不超过`100`个字符的短句:

```
print("---------------------------------")
print("three randomly-generated sentences of no more than 100 characters")
print("---------------------------------")

for i in range(3):
    print(TextModel.make_short_sentence(100))
```

同样，在这种情况下，主指令是包含`TextModel.make_sentence ()`函数的指令。其余的都只是用来格式化返回的句子。下面的屏幕截图显示了代码返回的句子示例:

![](Images/edbcec22-d036-45fd-aa95-46c2cbb267d0.png)

我必须承认，我很难说这是机器生成的文本。在这个简短的例子中，我们看到了这种算法所展现的巨大潜力。现实世界中的应用是多种多样的:创建响应人类用户需求的机器人，从句子集创建诗歌和歌曲，从名字创建新的别名，等等。这些当然是有趣的话题。

尽管如此，我们必须通过这种方法解决文本生成的缺点。它本质上是随机的，有时会导致不良的结果。读者了解这一点至关重要。

<title>Unknown</title>  <link href="../stylesheet.css" rel="stylesheet" type="text/css"> <link href="../page_styles1.css" rel="stylesheet" type="text/css">

# 摘要

在这一章中，我们看了随机过程及其应用。我们开始研究随机漫步模型。随机行走是用于描述由一系列随机步骤给出的路径的数学模型，根据我们想要描述的系统，这些随机步骤可能具有一定数量的自由度或方向。我们已经学习了如何处理一维随机行走，并且我们已经看到了如何用 Python 语言编写模拟随机行走的代码。

然后我们被介绍到马尔可夫链。为了理解这个主题，我们向您简要介绍了概率计算。定义了先验概率、联合概率和条件概率，并给出了它们的计算实例。然后我们继续讨论马尔可夫链的定义。马尔可夫链是一种随机现象的数学模型，这种随机现象随着时间的推移以这样一种方式演变，即过去只通过现在影响未来:换句话说，它是一种描述一系列可能事件的随机模型，其中每个事件的概率只取决于前一个事件达到的状态。我们学习了定义和阅读转换矩阵和转换图。我们使用马尔可夫链来预测连续 200 天的天气状况。

最后，我们使用一个马尔可夫链库来生成伪随机文本，它使用了一部美国文学名著:马克·吐温的《汤姆·索亚历险记》。