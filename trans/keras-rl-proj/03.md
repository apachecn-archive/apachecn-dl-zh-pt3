

# 三、最优投资组合选择

最优投资组合的选择是一个典型的决策问题，因此，其解决方案由以下要素组成:确定一组备选方案，使用选择标准对不同的可能性进行排序，最后是问题的解决方案。**动态规划** ( **DP** )代表一组算法，在给定一个以**马尔可夫决策 P** **过程** ( **MDP** )形式的完美环境模型的情况下，这些算法可以用来计算最优策略。DP 方法基于后继状态的值的估计来更新状态的值的估计，或者基于过去的估计来更新估计。在动态规划中，一个优化问题被分解成更简单的子问题，每个子问题的解被存储起来，这样每个子问题只被求解一次。在本章中，我们将通过 Python 代码实现来学习如何使用 DP 选择最优投资组合。

本章涵盖以下主题:

*   DP 特性
*   动态规划方法
*   递归和记忆
*   背包问题
*   DP 应用

在本章结束时，读者将理解优化技术的基本概念，知道如何将一个问题分解成子问题，知道如何使用 DP 方法来减少 Fibonacci 级数演算的计算成本，理解递归和记忆之间的区别，并理解背包问题的基础以及如何将其应用于最优投资组合选择问题。



# 动态规划

DP 是 20 世纪 50 年代发展起来的一种数学方法，主要由理查德·贝尔曼提出。它允许我们处理某些类型的问题，在这些问题中，必须按顺序做出一系列相互依赖的决定。它基于贝尔曼的优选原则。动态编程。新泽西州普林斯顿普林斯顿大学出版社。再版 2003: Dover，ISBN 0-486-42809-5 ，其陈述了最优策略具有这样的属性，即无论初始状态和初始决策是什么，剩余的决策都必须构成相对于第一个决策产生的状态的最优策略。

例如，考虑寻找连接两个位置的最佳路径的问题。最优性原理表明，在任何中间位置和最终位置之间，包含在其中的每个子路径必须依次是最优的。基于这一原则，DP 通过一次做出一个决定来解决问题。在每一步，确定未来的最佳政策，不考虑过去的选择(这是一个马尔可夫过程)，假设后面的选择也是最优的。

因此，当原始问题可以分解成一组更小的子问题时，当支付的成本或获得的利润表示为与每个决策相关的基本成本的总和时，动态规划是有效适用的。更一般地说，成本必须通过运算符表示为基本成本的组合，每个成本都依赖于一个决策。

下图显示了所有可用路径中网络两个节点之间的最佳(即最短)路径:

**![](Images/f9df077d-40a0-4027-81fc-4322ca745bb0.png)**

有许多路径可以到达同一个目的地:只有一条是最短的。



# 分而治之与动态编程

为了理解 DP 背后的机制，我们可以将其与另一种非常常见的解决问题的机制进行比较:分而治之。通过这种机制，一个问题被细分为两个或更多的子问题，并且原始问题的解从子问题解开始构造。这是一种自上而下的技术，按照以下步骤执行:

1.  将问题实例分成两种或多种物质
2.  递归求解每个子实例的问题
3.  重组子问题解以获得全局解

这种机制被广泛应用于多个问题的解决。最流行的应用是两种最常用的排序算法:快速排序和合并排序。

例如，在快速排序算法中，要排序的列表元素被分成两个块——一个 pivot 的较小块和较大块——并在这两个块上递归调用该算法。

在有些情况下，分而治之是不适用的，因为我们不知道如何获得子问题:问题没有包含足够的信息，让我们决定如何把它分成几个部分。

在这种情况下，DP 开始发挥作用。我们继续计算所有可能的子问题的解，并且从子解开始我们获得新的子解，逐步解决原始问题。与分治策略不同，要解决的子问题不一定是不连贯的，这意味着同一个子问题可能是几个子问题共有的。为了避免重新计算相同的子问题，子问题用自下而上的策略来解决——从最小的子问题到最大的子问题——并且这些子问题的解被存储在适当的表中，以便在必要时它们可用于其它子问题的解。

下图比较了这两种方法:

![](Images/a415d2bb-18f8-4ef1-9347-88343789accd.png)

根据上图所述，我们可以推断出 DP 用于存在问题的递归定义的情况，但是由于基于来自不同递归调用的相同数据子集的重复计算，将该定义直接转换为算法会产生指数级复杂性的程序。一个例子是斐波那契数的计算，我们后面会详细分析。



# 记忆化

我们已经看到 DP 是一种更有效地解决递归问题的技术。为什么会这样呢？在递归过程中，我们经常重复解决子问题。在 DP 中，这种情况不会发生:我们记住了这些子问题的解决方案，这样我们就不必再去解决它们了。这叫做记忆化。

如果给定步骤的变量值取决于先前计算的结果，并且如果相同的计算被反复重复，那么存储中间结果是方便的，以避免重复计算开销大的计算。

为了更好地理解递归和记忆之间的区别，让我们分析一个简单的例子:计算一个数的阶乘。具体来说，这是一个自然数 *n* 的阶乘，用 *n* 表示！，并且是小于或等于该数的正整数的乘积。下面的公式给出了 *n* 的阶乘的计算:

![](Images/dae84652-9930-4b3c-a01c-1fb4a84fc765.png)

数字阶乘的计算也可以递归定义，如下所示:

![](Images/9f77c23d-2195-4305-a995-f7936bf8230f.png)

如果一个函数调用它自己，它就被称为递归的。递归函数只能直接解决问题的特殊情况，称为基本情况(如前面公式中出现的情况)；如果通过传递一些构成基本情况之一的数据来调用它，那么它将返回一个结果。在每次调用时，数据都会减少，因此在某一点上，我们会到达一个基本情况。当函数调用自身时，它会暂停执行以进行新的调用。当对自身的内部调用结束时，执行继续。当最里面的一个(嵌套的)遇到基本情况之一时，递归调用序列结束。

让我们看一个 Python 中的简单函数，它通过递归过程计算一个数的阶乘:

```
import time
time_start = time.clock()
def factorial (x):
    if x == 0:
        return 1
    else:
        return x * factorial (x-1)
print("Factorial of 10 is: ",factorial (10))
print("Computational time is: ",time.clock() - time_start)
```

在函数内部有一个带有两个选项的`if`结构:在`x`大于或等于`1`之前，函数调用自己；当`x == 0`时，停止。对阶乘(`n-1`)的调用要求函数解决一个比初始问题更简单的问题(意味着值会更低)，但它总是同一个问题。该函数继续调用自己，直到它到达可以立即解决的基本情况。`time.clock()`函数用于计算计算成本。结果如下面的代码片段所示:

```
Factorial of 10 is: 3628800
Computational time is: 0.00022297111682249322
```

考虑到所使用的递归算法的性质，这个程序需要调用 *n + 1* 次阶乘函数才能得到结果，而每次调用都有一个与函数返回计算值所用时间相关的开销。

该程序可以通过使用以下方法进行记忆来改进:

1.  创建一个变量来存储临时结果(`storeX`)。
2.  在执行计算之前，请确定计算是否已经完成。如果是，使用存储的结果。
3.  如果这是我们第一次执行计算，请存储结果以备将来使用。

下面的代码显示了该程序的一个记忆版本:

```
import time
time_start = time.clock()

storeX ={}
def factorial (x):
    if x in storeX:
        return storeX[x]
    elif x == 0:
        return 1
    else:
        xt = x * factorial(x-1)
        storeX[x] = xt
        return xt

print("Factorial of 10 is: ",factorial (10))
print("Computational time is: ",time.clock() - time_start)
```

记忆化使得一个函数被调用的次数越多，时间效率就越高，最终导致整体速度的提高。以下代码片段显示了结果:

```
Factorial of 10 is: 3628800
Computational time is:0.00012497111682249322
```

从两个计算成本的比较可以看出，使用 memoization 的版本速度更快。



# 强化学习应用中的动态规划

DP 代表一组算法，在给定 MDP 形式的完美环境模型的情况下，这些算法可用于计算最佳策略。DP 的基本思想，以及一般的强化学习，是利用国家价值和行动来寻找好的政策。

DP 方法通过称为策略评估和策略改进的两个过程的迭代来解决马尔可夫决策过程，概述如下:

*   政策评估算法包括应用迭代方法求解贝尔曼方程。由于仅对 *k → ∞* 保证收敛，我们必须满足于通过施加停止条件得到良好的近似。
*   策略改进算法基于当前值改进策略。

策略迭代算法的缺点是，在每一步，我们都必须评估一个策略。这涉及一个迭代过程，在此过程中，我们事先不知道收敛的时间，这将取决于如何选择起始策略等。

克服这个缺点的一个方法是在特定的步骤切断对策略的评估。该操作不会改变收敛到最优值的保证。策略评估在某个步骤(也称为扫描)被阻止的特殊情况定义了值迭代算法。在值迭代算法中，在策略改进的每个步骤之间执行值计算的单次迭代。

因此，动态规划算法本质上是基于并行发生的两个过程:政策评估和政策改进。这两个过程的反复执行使得一般过程向最优解收敛。在策略迭代算法中，两个阶段交替进行，每个阶段在另一个阶段开始之前结束。

DP 方法通过环境可以假设的整个状态集进行操作，在每次迭代中对每个状态执行完整的备份。由备份执行的每个更新操作基于所有可能的后续状态的值来更新状态的值，对它们发生的概率进行加权，并且由选择的策略和环境的动态性来诱导。完整备份与贝尔曼方程密切相关；它们只不过是将等式转换成赋值指令。

当完整的备份迭代没有给状态值带来任何变化时，获得收敛，因此最终状态值完全满足贝尔曼方程。只有当交流发电机有一个完美的模型时，DP 方法才适用，该模型必须等同于 MDP。

正是由于这个原因，DP 算法在强化学习中用处不大，这是因为它们对环境的完美模型的假设，以及它们的高且昂贵的计算，但是提及它们仍然是重要的，因为它们代表了强化学习的理论基础。事实上，所有强化学习方法都试图实现与动态规划方法相同的目标，只是计算成本更低，并且不需要假设环境的完美模型。

相对于基于直接搜索的方法所需的指数运算( *n* )和动作( *m* )的数量，DP 方法使用多个多项式运算收敛到最优解。

DP 方法基于后继状态的值的估计来更新状态的值的估计，或者基于过去的估计来更新估计。这代表了一种称为引导的特殊属性。强化学习的几种方法执行引导，甚至不需要如 DP 方法所要求的完美环境模型的方法。



# 优化金融投资组合

金融投资组合管理是一项旨在以最能代表投资者需求的方式组合金融产品的活动。这需要对各种特征进行全面评估，如风险偏好、预期回报和投资者消费，以及对未来回报和风险的估计。

为了优化金融投资组合，我们首先要衡量可用产品的收益率和风险。风险回报变量可以被视为一枚硬币的两面，因为一定程度的风险对应于一定的回报。回报可以定义为投资产生的结果与所用资本的总和，而风险的概念可以解释为与特定金融工具相关的回报的可变性程度。

下图显示了马科维茨有效边界:

![](Images/fbf5bd6e-b6b7-4884-909d-24223a452bfb.png)

金融工具组合的风险可以通过不同活动的组合来降低，这些活动彼此之间并不完全相关；实际上，这些活动的回报不会随着时间的推移而同步变化。这一理论是由经济学家哈里·马科维茨创立的。Markowitz 在 1952 年引入了分散化的概念，该概念指出分散化投资组合的风险将低于与单个资产相关的平均风险；资产回报之间的相关性越低，这种影响就越明显。除此之外，还需要定义投资者的目标和偏好。

为了建立优化的投资组合，保证最佳的风险回报平衡，同时满足投资者的目标和偏好，我们将使用一种优化算法，属于在不同领域使用的特定算法类别，包括人工智能。但在此之前，我们将一步一步地分析流程优化技术的基础。



# 优化技术

优化问题是其解决方案可以根据成本函数(也称为目标)来衡量的问题。要寻找的值通常是该函数的最小值或最大值。最优化问题可以归结为一系列决策问题。

为了解决优化问题，有必要使用迭代算法——也就是说，给定解的当前近似，计算程序通过适当的操作序列来确定新的近似。从最初的近似开始，问题的一系列可能的解决方案就这样被确定了。

最优解的搜索算法分为以下三类:

*   **枚举技术**:枚举技术在函数定义域的所有点上寻找最优解。简化可以通过将问题简化为更简单的子问题来实现。动力定位就是这些技术中的一种。
*   **数值技术**:数值技术使用一组解决最优化问题必须满足的充要条件。这些可以分为直接和间接。间接方法通过求解一组非线性函数并迭代搜索该解来寻找函数的最小值，直到代价函数的梯度为零。直接法用梯度来引导对解的搜索。
*   **概率技术**:概率技术是基于枚举技术，但是它们使用额外的信息来进行研究，并且可以被视为进化过程。这一类包括模拟退火算法(使用热力学进化过程)和遗传算法(利用生物进化技术)。

在本章中，我们将讨论基于动态规划的优化技术。



# 用动态规划法求解背包问题

我们在前面的章节中介绍了 DP。现在是解决实际问题的时候了。我们将通过分析一个自 1897 年以来已经研究了一个多世纪的经典问题来做到这一点:背包问题。第一个处理这个问题的是数学家托拜厄斯·丹齐格，他把这个名字建立在一个常见的问题上，即把最有用的东西装进背包，而不使它超载。

这种类型的问题可能与现实生活中出现的不同情况有关。为了更好地描述这个问题，我们将提出另一个相当独特的问题。一个小偷进入一所房子，想偷贵重物品。他们把它们放在背包里，但是它们受到重量的限制。每个物体都有自己的价值和重量。他必须选择那些有价值但又不过重的物品。小偷不能超过背包中的重量限制，但同时，他们必须优化他们的收益。

现在，我们将从数学的角度来解决这个问题。假设我们有一个由 *n* 个对象组成的集合( *X* ，用从 *1* 到 *n 的整数标注:{1，2，...，n}* 。这些对象满足以下条件:

*   第 *i* 个对象有重量(*p【I】*)和值(*v【I】*)
*   每个对象只有一个实例

我们有一个容器，它最多能承载等于 P 的重量。我们想要确定对象的子集( *Y* ⊆ *X* )，从而满足以下标准:

*   *Y* 中物体的总重量为 *≤ P*

*   *Y* 中对象的总值是最大可能值

这最后两个条件采用以下代数形式:

*   我们想要确定对象的子集( *Y* ⊆ *X* )，使得满足以下条件:

![](Images/70352f04-2b13-4f53-b387-fd5a8eda69f1.png)

*   我们希望最大化以下总体价值:

![](Images/4ffb748c-c6fd-4cac-a5d5-ae70123b7b4b.png)

正如人们所说，这是一个优化问题。通常，优化问题由两部分组成:

*   一组必须遵守的约束(可能是空的)
*   必须最大化或最小化的目标函数

我们用来定义这个问题的数学形式明确地阐明了这两个要素。许多实际问题可以相对简单地表述为优化问题，然后用计算器解决。把一个新问题简化为一个已知问题，可以利用现有的解决方案。

和大多数问题一样，即使是最优化问题，也有不同的方法让我们找到解决方案。当然，它们随着每个算法在时间和内存需求以及所需的编程工作方面的复杂性而不同。

这个问题有两个版本:

*   0–1 背包问题:每一个物品都必须被完全接受或拒绝
*   分数背包问题:我们可以取物品的分数

换句话说，在 0–1 背包问题中，我们不允许打破物品。我们要么接受整个项目，要么不接受。相比之下，在分数背包中，我们可以分解物品以最大化背包内容的总价值。

背包问题可以很容易地应用于金融投资组合的优化问题。事实上，我们可以将对象的权重与我们正在考虑的金融产品的风险权重进行比较，并将对象的价值与金融产品的预期价值进行比较。基于这些假设，可以选择最大化预期价值的金融产品，同时将风险保持在特定值以下。



# 解决问题的不同方法

在下一节中，我们将使用三种不同的方法来解决背包问题:

*   强力
*   贪婪算法
*   动态规划

在接下来的几节中，我们将看看每个解决方案的优缺点。



# 强力

蛮力是一种非常通用的问题解决技术，它包括系统地列出所有可能代表解决方案的值，并检查每个值是否满足问题所强加的条件。

一个强力算法实现起来很简单，如果存在的话总会找到一个解，但是它的代价与可能的解的数量成正比。因此，当问题的规模有限时，或者当假设允许我们减少可能的解决方案集时，通常使用蛮力研究。当实现的简单性比速度更重要时，也使用该方法。

强力是背包问题最直接的解决方案:检查所有可能的填充背包的方法，这些方法是*2^n，并打印一个最优解(可能不止一个)。这对于 *n > 15* 来说已经很慢了。这种算法通常直接基于问题的定义和所涉及概念的深化。*

这种简单算法的关键要素如下:

*   列举所有可能的组合
*   选择最佳解决方案(我们遍历所有组合，找到具有最大值且总权重小于或等于 *P* 的一个)
*   确保最佳性
*   时间成本极高，对于大*n*；运行时间将为 *O(2 ^n )*

以下是用于解决 0–1 背包问题的代码示例:

```
import itertools

objects = [(5, 18),(2, 9), (4, 12), (6,25)]

print("Items available: ",objects)
print("***********************************")

AllCombination = [comb for k in range(0, len(objects)+1) for comb in itertools.combinations(objects, k)]

print("All combination: ")
for x in range(len(AllCombination)):
    print(AllCombination[x]),

print("***********************************")
def ConditionControl(Subset):
    totweight = totvalue = 0
    for weight, value in Subset:
        totweight += weight
        totvalue += value
    return (totvalue, totweight) if totweight <= 10 else (0, 0)
Subset = max(AllCombination, key=ConditionControl)
print("Subset selected: ",Subset)

value, weight = ConditionControl(Subset)
print("Total value: " ,value)
print("Total weight: ",weight)
```

我们将逐行分析这段代码。第一行加载库:

```
import itertools
```

模块实现了许多迭代器构建块，灵感来自 APL、Haskell 和 SML 的构造。每一个都被改写成适合 Python 的形式。该模块标准化了一组快速、内存高效的核心工具，这些工具可以单独使用，也可以组合使用。它们一起形成了一个迭代器代数公式，使得用纯 Python 简洁高效地构造专用工具成为可能。然后，传递一组项目，如下面的代码所示:

```
objects = [(5, 18),(2, 9), (4, 12), (6,25)]
```

每一对代表小偷在房子里找到的每件物品的重量和价值。这些对象已包含在列表中。列表类型是一个容器，以给定的顺序保存许多其他对象。列表类型实现了序列协议，并允许您在序列中添加和删除对象。此时，导入的对象被打印出来，如下所示:

```
print("Items available: ",objects)
print("***********************************")
```

以下代码显示了获得的结果:

```
Items available: [(5, 18), (2, 9), (4, 12), (6, 25)]
***********************************
```

现在有必要使用以下代码来确定对象的所有可能组合:

```
AllCombination = [comb for k in range(0, len(objects)+1) for comb in itertools.combinations(objects, k)]
```

为了确定对象的所有组合，使用了`itertools.combinations()`函数。这个函数从输入 iterable 返回元素的长度子序列。组合是按字典顺序发出的。因此，如果输入 iterable 是排序的，组合元组将按排序的顺序产生。元素被视为唯一是基于它们的位置，而不是它们的值。因此，如果输入元素是唯一的，则每个组合中不会有重复的值。然后打印所有计算出的组合，如下所示:

```
print("All combination: ")
for x in range(len(AllCombination)):
    print(AllCombination[x]),
print("***********************************")

```

为了打印每行的组合，使用了一个`for`语句。然后，打印一些标记以更好地呈现结果。现在，需要一个新的函数定义，如下面的代码所示:

```
def ConditionControl(Subset):
    totweight = totvalue = 0
    for weight, value in Subset:
        totweight += weight
        totvalue += value
    return (totvalue, totweight) if totweight <= 10 else (0, 0)
```

`ConditionControl()`功能检查重量。众所周知，背包问题必须满足这样的条件，即物体的总重量必须小于或等于预先确定的重量。在我们的例子中，我们把它固定在 10。将对子集变量中包含的每个组合进行检查。对于每个组合，将计算总重量和总价值。如果总重量小于或等于 10，则返回总重量和总值。是时候选择要带走的物品组合了，如下面的代码所示:

```
Subset = max(AllCombination, key=ConditionControl)
```

`max()`功能用于选择最佳子集。此函数返回 iterable 中最大的项或两个或多个参数中最大的项。如果提供了一个位置参数，它应该是可迭代的。返回 iterable 中最大的项。如果提供了两个或更多位置参数，则返回最大的位置参数。有两个可选的仅关键字参数。其中一个是 key 参数，它指定了一个单参数排序函数。传递了一个关键参数`ConditionControl()`函数。为了显示选中的子集，调用一个`print()`函数，如下所示:

```
print("Subset selected: ",Subset)
```

既然已经选择了最佳组合，剩下的就是导出与之相关的值，如下所示:

```
value, weight = ConditionControl(Subset)
```

为了提取与所选子集相关联的总权重和总值，调用`ConditionControl()`函数并传递所选子集。最后，提取的值显示如下:

```
print("Total value: " ,value)
print("Total weight: ",weight)
```

以下屏幕截图显示了返回的 0–1 背包问题解决方案的结果:

![](Images/b8cdefcd-a13b-4927-910f-a37842b364d4.png)

正如预期的那样，我们刚刚看到的问题的最优解是最直接的，但从计算的角度来看也是最昂贵的。在接下来的几节中，我们将看看另一个在计算方面更经济的解决方案。



# 贪婪算法

在引入贪心算法来寻找背包问题的最优解之前，回忆一下任何贪心技术的主要特征是适当的。任何贪婪的技术都是反复进行的。从一个空解开始，在每次迭代中，元素 *A* 被添加到正在构建的部分解中。在所有可能被添加的候选元素中，元素 *A* 是最有希望的一个——也就是说，如果被选择，元素 *A* 导致目标函数的更大改善。很明显，并不是所有的问题都可以用这种策略来解决，但只有那些有可能表明此时做出最佳选择会导致全局最优解的问题才可以解决。

让我们来看一个简单执行以下操作的算法:

*   丢弃所有重量超过最大容量的物体(预处理)
*   根据给定标准对对象进行排序
*   一次选择一个对象，直到符合重量约束
*   返回解决方案的值和一组选定的对象

看看下面的代码，这是一个贪婪算法的例子:

```
P = 10
objects = [(5, 18),(2, 9), (4, 12), (6,25)]
print("Items available: ",objects)
print("***********************************")
objects = filter(lambda x: x[0]<=P, objects)
objects = sorted(objects, key=lambda x: x[0])
weight, value, subset = 0, 0, []
print("Items filtered and sorted: ",objects)
print("***********************************")
for item in objects:
    if weight + item[0] <= P:
        weight = weight + item[0]
        value = value + item[1]
        subset.append(item)
print("Subset selected: ",subset)
print("Total value: ",value)
print("Total weight: ",weight)
```

我们将逐行分析这段代码。第一行设置权重约束:

```
P = 10
```

然后传递一个项目列表，如下所示:

```
objects = [(5, 18),(2, 9), (4, 12), (6,25)]
```

每一对代表小偷在房子里找到的每件物品的重量和价值。这些对象已包含在列表中。`list`类型是一个容器，以给定的顺序保存许多其他对象。`list`类型实现了序列协议，还允许您在序列中添加和删除对象。此时，导入的对象被打印出来，如下所示:

```
print("Items available: ",objects)
print("***********************************")
```

结果如下面的代码片段所示:

```
Items available: [(5, 18), (2, 9), (4, 12), (6, 25)]
***********************************
```

为了便于比较不同的技术，我们使用了与上一个例子相同的数据集。现在，我们将丢弃重量超过最大容量的所有物品，如下所示:

```
objects = filter(lambda x: x[0]<=P, objects)
```

为此，使用了`filter()`功能。函数从 iterable 的元素中构造一个迭代器，函数为 iterable 返回`true`。换句话说，这个函数在测试 iterable 中的每个元素是否为`true`的函数的帮助下过滤给定的 iterable。`filter()`函数的语法如下:

```
filter(function, iterable)
```

`filter()`函数有两个参数:

*   `function`:这个函数测试一个`iterable`的元素是返回`true`还是`false`。如果没有，该函数默认为`identity`函数，如果有任何元素为`false`，则返回`false`。

*   `iterable`:这是要过滤的 iterable。它可以是集合、列表、元组或任何迭代器的容器。

在我们的例子中，函数是`lambda x: x[0]<=P`，它检查重量限制，要过滤的`iterable`是 objects。为了优化内存空间，更新了`objects`列表。我们现在可以致力于根据某个标准对对象进行排序，如下所示:

```
objects = sorted(objects, key=lambda x: x[0])
```

为了以特定的顺序对`objects`列表的元素进行排序，使用了`sorted()`函数。该函数从给定的`iterable`中返回一个`sorted`列表。这将给定的`iterable`的元素以特定的顺序排序——升序或降序。默认顺序是升序。用作排序比较的关键字的`lambda`函数被传递。在我们的例子中,`objects`的列表按照代表权重的每对值的第一个元素进行升序排序。此时，数据准备阶段已经结束，我们可以继续选择`objects`，如下所示:

```
weight, value, subset = 0, 0, []
print("Items filtered and sorted: ",objects)
print("***********************************")
```

第一行用于初始化三个变量，`weight`、`value`和`subset`，它们分别代表列表中可用对象的权重、值和子集。然后，打印所有已过滤和排序的项目，以便与之前打印的起始列表进行比较。现在让我们用一个`for`循环浏览一下列表，如下所示:

```
for item in objects:
    if weight + item[0] <= P:
        weight = weight + item[0]
        value = value + item[1]
        subset.append(item)
```

在每一轮中，考虑一个对象:如果总重量没有超过条件施加的限制，则重量和总值被更新，并且该对象被添加到背包中。最后，打印结果，如下所示:

```
print("Subset selected: ",subset)
print("Total value: ",value)
print("Total weight: ",weight)
```

结果如以下截图所示:

![](Images/e673dfa0-d06e-41f1-9139-cfee774e41e7.png)

正如我们在前面的截图中看到的，即使不是最佳解决方案，也已经获得了一个结果。事实上，与我们在上一节中看到的强力算法获得的解决方案相比，插入背包中的对象的价值要低得多(`21`对`37`):算法改进是必要的。

该算法的一个可能的改进是首先基于值的密度执行对象的降序前序，计算如下:

![](Images/4a6218af-420f-4e99-b91d-e023d225cee4.png)

这项技术在下面的代码中实现:

```
P = 10
objects = [(5, 18),(2, 9), (4, 12), (6,25)]
print("Items available: ",objects)
print("***********************************")
objects = filter(lambda x: x[0]<=P, objects)
objects = sorted(objects, key=lambda x: x[1]/x[0], reverse=True)
weight, value, subset = 0, 0, []
print("Items filtered and sorted: ",objects)
print("***********************************")
for item in objects:
    if weight + item[0] <= P:
        weight = weight + item[0]
        value = value + item[1]
        subset.append(item)
print("Subset selected: ",subset)
print("Total value: " ,value)
print("Total weight: ",weight)
```

我们将逐行分析这段代码。如前所述，在第一行中，已经设置了权重约束:

```
P = 10
```

然后传递一个项目列表，如下所示:

```
objects = [(5, 18),(2, 9), (4, 12), (6,25)]
```

此时，导入的对象被打印出来，如下所示:

```
print("Items available: ",objects)
print("***********************************")
```

结果显示在以下代码中:

```
Items available: [(5, 18), (2, 9), (4, 12), (6, 25)]
***********************************
```

我们使用了与上一个例子相同的数据集，以便于比较不同的技术。现在，我们将丢弃重量超过最大容量的所有物品，如下所示:

```
objects = filter(lambda x: x[0]<=P, objects)
```

为此，使用了`filter()`功能。为了优化存储空间，更新了`objects`列表。我们现在可以致力于根据某个标准对对象进行排序，如下所示:

```
objects = sorted(objects, key=lambda x: x[1]/x[0], reverse=True)
```

为了对`objects`列表进行排序，使用了`sorted()`功能。`sorted()`功能的使用与前一种情况略有不同。在这种情况下，`lambda `函数根据不同的标准对数据进行排序:`lambda x: x[1]/x[0]`。最后，进行降序排列。此时，数据准备阶段已经结束，我们可以继续选择对象，如下所示:

```
weight, value, subset = 0, 0, []
print("Items filtered and sorted: ",objects)
print("***********************************")
```

第一行用于初始化三个变量，`weight`、`value`和`subset`，它们分别代表列表中可用对象的权重、值和子集。然后打印所有已过滤和排序的项目，以便与之前打印的起始列表进行比较。现在让我们用一个`for`循环浏览一下列表，如下所示:

```
for item in objects:
    if weight + item[0] <= P:
        weight = weight + item[0]
        value = value + item[1]
        subset.append(item)
```

在每一轮中，考虑一个对象:如果总重量没有超过条件施加的限制，则重量和总值被更新，并且该对象被添加到背包中。最后，打印结果，如下所示:

```
print("Subset selected: ",subset)
print("Total value: ",value)
print("Total weight: ",weight)
```

结果如以下截图所示:

![](Images/3f2e9f28-da4a-42c3-966a-df616fe721a0.png)

从前面截图的分析中，我们可以看到，即使在这种情况下，我们也没有获得最优解，但另一方面，选择了一个明显更大的值(`34`对`21`)。



# 动态规划

在前面的章节中，我们已经看到了如何通过不同的方法来解决背包问题。特别是，我们学会了用一种叫做蛮力的算法来处理这个问题:在这种情况下，我们以极其沉重的计算代价获得了最优解。另一方面，贪婪解决方案从计算的角度给了我们一个较轻的算法，但不允许我们获得最优解。DP 可以提供结合了这两种需求的解决方案，即最佳解决方案和快速算法。

正如我们在 DP 一节中所说的，我们将一个优化问题细分为更简单的子问题，并存储每个子问题的解，这样每个子问题只被解决一次。我们将使用的方法背后的思想是一次计算子问题的解，并将解存储在一个表中，以便它们可以在以后被重复使用。

以下是使用 DP 的背包问题解决方案:

```
def KnapSackTable(weight, value, P, n):
    T = [[0 for w in range(P + 1)]
            for i in range(n + 1)]
    for i in range(n + 1):
        for w in range(P + 1):
            if i == 0 or w == 0:
                T[i][w] = 0
            elif weight[i - 1] <= w:
                T[i][w] = max(value[i - 1]
                            + T[i - 1][w - weight[i - 1]],
                                              T[i - 1][w])
            else:
                T[i][w] = T[i - 1][w]
    res = T[n][P]
    print("Total value: " ,res)
    w = P
    totweight=0
    for i in range(n, 0, -1):
        if res <= 0:
            break
        if res == T[i - 1][w]:
            continue
        else:
            print("Item selected: ",weight[i - 1],value[i - 1])
            totweight += weight[i - 1]
            res = res - value[i - 1]
            w = w - weight[i - 1]

    print("Total weight: ",totweight)

objects = [(5, 18),(2, 9), (4, 12), (6,25)]
print("Items available: ",objects)
print("***********************************")
value = []
weight = []
for item in objects:
    weight.append(item[0])
    value.append(item[1])
P = 10
n = len(value)
KnapSackTable(weight, value, P, n)
```

我们将逐行分析这段代码。该算法从定义一个`KnapSackTable()`函数开始，该函数将根据问题施加的两个约束条件选择对象的最佳组合:对象的总权重等于 10，以及所选对象的最大值，如以下代码所示:

```
def KnapSackTable(weight, value, P, n):
    T = [[0 for w in range(P + 1)]
            for i in range(n + 1)]
```

首先，我们定义并初始化包含值的表。该表是以自下而上的方式逐行构建的，如下表所示:

![](Images/aa4742ee-8cfc-4e55-a5e1-d53b3e21e82c.png)

然后，我们对所有对象和所有`weight`值设置迭代循环，如下所示:

```
for i in range(n + 1):
    for w in range(P + 1):
        if i == 0 or w == 0:
            T[i][w] = 0
        elif weight[i - 1] <= w:
            T[i][w] = max(value[i - 1] + T[i - 1][w - weight[i - 1]], T[i - 1][w])
        else:
            T[i][w] = T[i - 1][w]
```

第一个`If`语句构造了表格的第一行和第一列。特别是，我们将第一行初始化为`0`，这对应于这样的情况，对于不同的可运输重量，我们没有对象(`T[0, w] = 0`)。将第一列初始化为`0`，对应的情况是，对于几个可能的对象，我有一个容量为零的背包(`T [i, 0] = 0`)。`elif`选项包含对当前物体重量的进一步检查。如果满足控制，则根据以下公式更新当前单元格:`T [i] [w] = max (value [i - 1] + T [i - 1] [w - weight [i - 1]], T [i - 1] [w])`。最后，`else`选项不考虑当前对象，并把它放在与前一行相同的位置。一旦到达表的最后一行的最后一个单元格，我们就可以记住所获得的结果，该结果表示背包中可以携带的物品的最大值，如下所示:

```
res = T[n][P]
print("Total value: " ,res)
```

到目前为止所遵循的程序并没有指出哪个子集提供了最佳解决方案。我们必须用一套固定的程序提取这一信息。我们将只分析表的最后一列(`w = P`)，然后我们将从最后一个值开始向下遍历到最上面的一个值。

如果当前元素与前一个相同，我们将继续下一个；否则，当前对象将被包含在背包中。这显示在以下代码中:

```
w = P
totweight=0
for i in range(n, 0, -1):
    if res <= 0:
        break
```

如果当前元素与前一个元素相同，我们将继续下一个元素，如下所示:

```
    if res == T[i - 1][w]:
        continue
```

如果不相同，则当前对象将被包含在背包中，并打印该物品，如下所示:

```
    else:
        print("Item selected: ",weight[i - 1],value[i - 1])
        totweight += weight[i - 1]
        res = res - value[i - 1]
        w = w - weight[i - 1]
```

最后，打印包括的总重量，如下所示:

```
    print("Total weight: ",totweight)
```

这样，我们就定义了允许我们构建表的函数。现在我们必须定义输入变量并将它们传递给函数，如下所示:

```
objects = [(5, 18),(2, 9), (4, 12), (6,25)]
print("Items available: ",objects)
print("***********************************")
```

现在，对象被定义和打印。让我们使用下面的代码初始化两个变量:

```
value = []
weight = []
```

此时，我们需要从对象中提取出`weight`和`value`变量值。为了更好地理解这些步骤，我们将它们放在单独的数组中，如下所示:

```
for item in objects:
    weight.append(item[0])
    value.append(item[1])
```

最后，背包可以承载的总重量和可用物品的数量设置如下:

```
P = 10
n = len(value)
```

我们只需调用函数并传递我们刚刚定义的数据，如下所示:

```
KnapSackTable(weight, value, P, n)
```

结果如以下截图所示:

![](Images/5cd0af2e-3602-4cd1-995e-ddff406e2999.png)

DP 算法允许我们获得最优解，节省了计算成本。



# 摘要

在这一章中，我们已经讨论了优化技术的基本概念。首先，我们学习了 DP 的基本内容。使用 DP，我们将优化问题细分为更简单的子问题。然后，我们继续计算所有可能的子问题的解，并从子解开始，我们获得新的子解，并继续下去，直到我们解决原来的问题。

然后，我们看了递归和记忆之间的区别。在动态规划中，这种情况不会发生:我们记住了这些子问题的解决方案，这样我们就不必再去解决它们；这叫做记忆化。这种方法背后的思想是一次性计算子问题的解，并将解存储在一个表中，以便以后可以重复使用。为了更好地理解这项技术，我们来看一个实际案例:计算一个数的阶乘。这个问题是用两种方法处理的:递归和记忆。从计算的角度来看，节省得到了证实。

在此之后，我们研究了金融投资组合的优化。金融投资组合管理是一项旨在寻求最符合投资者需求的金融产品组合的活动；这需要对各种特征进行全面评估，如风险偏好、预期回报和投资者消费，以及对未来回报和风险的估计。

最后，我们学习了背包问题的基础知识，以及如何将它们应用到最优投资组合选择中。这个问题通过三种不同的方法解决:暴力、贪婪算法和 DP。对于每种方法，提供了一个解决算法，并比较了结果。